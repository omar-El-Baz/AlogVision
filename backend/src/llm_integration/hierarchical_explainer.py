# src/llm_integration/hierarchical_explainer.py

import json
from .llm_client import LLMClient

class HierarchicalExplainer:
    """
    Uses an LLM to generate a multi-level, hierarchical explanation of code.
    """
    def __init__(self, llm_client: LLMClient):
        self.llm_client = llm_client

    def generate_explanation(self, code_string: str, code_analysis: dict, validated_purpose: dict = None, match_report: dict = None) -> str:
        """
        Generates a complete, layered explanation of the code,
        incorporating a purpose validation report if available.
        """
        purpose_context = "Not provided by user."
        if validated_purpose:
            purpose_context = json.dumps(validated_purpose, indent=2)

        # New: Context for the purpose alignment report
        match_report_context = "Not applicable (no user purpose provided for validation)."
        if match_report:
            match_report_context = json.dumps(match_report, indent=2)

        

        prompt = f"""
        You are an AI Python Tutor, a friendly and knowledgeable guide for aspiring programmers. Your mission is to demystify code and empower students by providing exceptionally clear, encouraging, and well-structured explanations. You aim to build intuition and practical understanding, not just describe syntax.

        Contextual Information:

        User's Goal:

        JSON

        {purpose_context}

        Purpose Alignment Report: (Generated by an AI validator comparing user's goal with code analysis)

        JSON

        {match_report_context}

        Automated Code Analysis:

        JSON

        {json.dumps(code_analysis, indent=2)}
        
        Full Python Code:

        Python

        {code_string}

        Your Task & Output Format:
        Generate a comprehensive, educational explanation of the Python code above. Structure your response in Markdown using the following *nine* sections. Your tone should be educational, patient, clear, and highly encouraging, as if you're tutoring a beginner who is eager to learn.

        ---

        ### 1. The Why: Real-World Motivation 🎯
        *   **Problem Statement:** Before diving into the code, describe a simple, relatable real-world problem or scenario that this code (or the underlying concept) helps to solve. Why would someone need this functionality?
        *   **Goal:** Briefly state how this code provides a solution to that problem, setting the stage for understanding its purpose.
        *   Example: "Imagine you have a list of student scores, and you want to quickly find out who got the highest grade. Manually checking each one would be tedious for a long list. This code helps automate similar 'finding' or 'processing' tasks efficiently."

        ### 2. The Big Picture 🗺️
        *   **What It Does:** Start with a concise, one-paragraph summary. What is the primary function or overarching goal of this script?
        *   **How It Works:** Briefly explain the core logic, strategy, or algorithm the code uses to achieve its goal. (e.g., "It uses a loop to iterate through items and apply a condition.")
        *   **Data Flow:** Describe the journey of the data. Where does it originate (e.g., user input, a file, hardcoded), how is it processed or transformed step-by-step, and what is the final output or result?
        *   **Purpose Alignment Insight:** **IMPORTANT:** Based on the 'Purpose Alignment Report', integrate its findings here.
            *   If `match_confidence` is high (e.g., > 0.7), enthusiastically emphasize how well the code aligns with the user's stated purpose, reinforcing their achievement.
            *   If `match_confidence` is low (e.g., < 0.7), clearly but kindly point out the discrepancy. Mention the 'reason' from the report and gently suggest that the code might be solving a slightly different problem, or the purpose description could be refined.

        ### 3. Key Concepts & Techniques 🧠
        Based on the static analysis and the code itself, identify 1-4 core programming concepts, data structures, or fundamental techniques a student should understand from this example. For each:
        *   **Name the Concept:** (e.g., "List Comprehension," "Recursion," "File Handling," "Dictionaries," "Conditional Statements").
        *   **Explain It Simply:** Describe what it is in easy-to-understand terms and why it's used effectively in *this specific code*. Use a simple analogy if helpful.
        *   Example: "Think of a `for` loop as a factory assembly line. It takes a collection of items (like a list) and performs the exact same action on each one, one by one, until all items have been processed."

        ### 4. Component Breakdown 🧩
        For each significant function, class, or global component (e.g., main script logic) identified in the analysis, create a subsection. If there are many small components, group related ones.
        *   **Component Name:** (e.g., `calculate_average(data)`, `MyProcessorClass`)
        *   **Purpose:** Explain its specific job and how it contributes to the overall script's goal.
        *   **Parameters (@param):** List and describe each input the function/method takes, what kind of data it expects, and why it needs it.
        *   **Returns (@return):** Describe what the function/method produces and sends back as a result, including its data type if clear.
        *   **Notes:** Add any relevant information from the static analysis (e.g., "This function is recursive," "This class manages resource allocation," "Error handling is implemented here.").

        ### 5. Step-by-Step: The Code in Action ➡️
        Walk through the code linearly, explaining logical chunks as if you're narrating its execution. This creates a clear narrative flow.
        *   **Code Chunk:** Display a small, logical block of code.
            ```python
            # Code chunk here
            # e.g., for i in range(n):
            #     total += i
            ```
        *   **Explanation:** Explain what this specific block does, why it's there, and how it moves the program closer to its goal. Link it back to the "Big Picture" and "Key Concepts." Mention variable states if helpful.

        ### 6. Complexity Analysis ⏱️
        Help the student understand how the code performs under different conditions.
        *   **Time Complexity (Big O):** Explain what time complexity means (how execution time grows with input size). Identify the primary operations that contribute to complexity (e.g., loops, nested loops, function calls). State the Big O notation for this code (e.g., O(n), O(n^2), O(log n)) and briefly explain *why* it is what it is.
        *   **Space Complexity (Big O):** Explain what space complexity means (how memory usage grows with input size). Identify any data structures or variables that consume significant memory. State the Big O notation for space and explain *why*.
        *   **Why It Matters:** Briefly explain why understanding complexity is important for efficient programming (e.g., "This helps us predict if our code will be fast enough for large datasets.").

        ### 7. Edge Cases & Robustness 🔒
        Discuss potential tricky situations and how the code handles them (or could handle them).
        *   **What are Edge Cases?** Briefly define edge cases (e.g., empty inputs, invalid inputs, single-item inputs, maximum values).
        *   **Code's Handling:** Analyze how the current code responds to 1-2 relevant edge cases. Does it work correctly, raise an error, or produce unexpected results?
        *   **Improving Robustness (if applicable):** Suggest how the code could be made more robust (e.g., adding input validation, `try-except` blocks, default values).

        ### 8. Real-World Applications 🌍
        Help the student connect this specific code example to broader programming contexts.
        *   **Broader Use Cases:** Discuss 2-3 other scenarios or domains where the techniques, algorithms, or design patterns used in this code are commonly applied.
        *   **Similar Problems:** Mention other types of problems that could be solved using a similar approach.

        ### 9. How to Run & Further Explore 🚀
        Provide practical, actionable steps and encourage active learning.
        *   **To Run This Code:** Give simple, clear instructions on how to execute the script. Assume they have Python installed.
        *   **Example Usage:** Provide a clear, runnable example. Show specific input you'd give it (if applicable) and the *exact output* you'd expect to see.
            ```
            # Example Input
            your_function([1, 2, 3]) 
            # Expected Output
            6
            ```
        *   **A Challenge for You:** Suggest a small, specific, and achievable modification or improvement the student could try. This encourages active learning and experimentation.
            *   **IMPORTANT:** If the 'Purpose Alignment Report' indicated a low confidence, structure your challenge around how the student could *modify the code to better meet the original purpose*, or how they might *clarify/refine their purpose description* to better match the code.
            *   If confidence was high, offer a challenge to extend the current, well-aligned functionality (e.g., "Try adding a feature to calculate the median," or "How would you make this function handle negative numbers?").
        *   **Potential Next Steps:** Briefly suggest what topics the student might explore next to deepen their understanding related to this code (e.g., "Look into more advanced data structures like queues," "Research different sorting algorithms," "Explore how to read data from a file.").

        ---

        Guiding Principles:

        *   **Clarity Above All:** Use simple, accessible language. Avoid jargon or explain it immediately and thoroughly. Assume the student has basic Python knowledge but needs concepts reinforced.
        *   **Be a Tutor, Not a Reference:** Your tone should be encouraging, empathetic, and conversational. Celebrate understanding and guide gently through challenges.
        *   **Leverage Provided Context:** Refer to the user's goal, the static analysis, and **especially the 'Purpose Alignment Report'** to make your explanation more relevant, insightful, and tailored.
        *   **Format for Readability:** Use Markdown effectively: bolding for key terms, clear code blocks for code, bullet points, and subheadings to break up text and improve navigation. Use emojis appropriately to enhance friendliness and section distinction.
        *   **No Pre-amble:** Start directly with "### 1. The Why: Real-World Motivation 🎯".
        """
        
        return self.llm_client.make_request(prompt)

if __name__ == '__main__':
    # This is a simplified example for demonstration.
    sample_code = """
def calculate_gcd(a, b):
    while b:
        a, b = b, a % b
    return a

num1 = 48
num2 = 18
result = calculate_gcd(num1, num2)
print(f"The GCD is {result}")
"""
    sample_analysis = {
        "high_level_summary": {
            "imports": [],
            "class_definitions": [],
            "total_functions": 1,
            "total_lines": 8
        },
        "functions": {
            "calculate_gcd": {
                "parameters": ["a", "b"],
                "return_statements": 1,
                "start_line": 2,
                "dependencies": {
                    "calls": [],
                    "uses_variables": ["b", "a"]
                }
            }
        },
        "line_by_line": [
            {"line_number": 2, "content": "def calculate_gcd(a, b):", "types": ["Function Definition"]},
            {"line_number": 4, "content": "while b:", "types": ["While Loop"]},
            {"line_number": 5, "content": "a, b = b, a % b", "types": ["Assignment"]},
            {"line_number": 6, "content": "return a", "types": ["Return Statement"]},
            {"line_number": 8, "content": "num1 = 48", "types": ["Assignment"]},
            {"line_number": 9, "content": "num2 = 18", "types": ["Assignment"]},
            {"line_number": 11, "content": "result = calculate_gcd(num1, num2)", "types": ["Assignment"]},
            {"line_number": 12, "content": "print(f\"The GCD is {result}\")", "types": ["Expression Statement"]}
        ]
    }
    
    # Example for when purpose matches
    sample_purpose_match = {
        "main_functionality": "Calculates the greatest common divisor (GCD) of two numbers using the Euclidean algorithm.",
        "key_algorithms": ["Euclidean algorithm", "iteration"],
        "inputs": "two integers",
        "outputs": "a single integer (the GCD)"
    }
    sample_match_report_high_conf = {
        "match_confidence": 0.95,
        "reason": "The code correctly implements the Euclidean algorithm for GCD, matching the described purpose and structure."
    }

    # Example for when purpose somewhat mismatches
    sample_purpose_mismatch = {
        "main_functionality": "Finds the factorial of a number using recursion.",
        "key_algorithms": ["recursion", "factorial"],
        "inputs": "a single integer",
        "outputs": "a single integer (the factorial)"
    }
    sample_match_report_low_conf = {
        "match_confidence": 0.15,
        "reason": "The code calculates GCD, not factorial, and uses iteration (while loop) instead of recursion as specified in the purpose."
    }


    client = LLMClient()
    explainer = HierarchicalExplainer(llm_client=client)

    print("--- Explanation with High Confidence Match ---")
    explanation_high_conf = explainer.generate_explanation(
        sample_code,
        sample_analysis,
        validated_purpose=sample_purpose_match,
        match_report=sample_match_report_high_conf
    )
    print(explanation_high_conf)
    
    print("\n--- Explanation with Low Confidence Mismatch ---")
    explanation_low_conf = explainer.generate_explanation(
        sample_code,
        sample_analysis,
        validated_purpose=sample_purpose_mismatch,
        match_report=sample_match_report_low_conf
    )
    print(explanation_low_conf)